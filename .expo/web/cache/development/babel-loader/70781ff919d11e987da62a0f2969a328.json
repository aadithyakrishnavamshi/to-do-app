{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useNavigationState;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _useNavigation = _interopRequireDefault(require(\"./useNavigation\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction useNavigationState(selector) {\n  var navigation = (0, _useNavigation.default)();\n\n  var _React$useState = React.useState(function () {\n    return selector(navigation.getState());\n  }),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      setResult = _React$useState2[1];\n\n  var selectorRef = React.useRef(selector);\n  React.useEffect(function () {\n    selectorRef.current = selector;\n  });\n  React.useEffect(function () {\n    var unsubscribe = navigation.addListener('state', function (e) {\n      setResult(selectorRef.current(e.data.state));\n    });\n    return unsubscribe;\n  }, [navigation]);\n  return selector(navigation.getState());\n}","map":{"version":3,"sources":["useNavigationState.tsx"],"names":["navigation","React","selector","selectorRef","unsubscribe","e","setResult"],"mappings":";;;;;;;;;AACA;;AAGA;;;;;;AAWe,SAAA,kBAAA,CAAA,QAAA,EAEV;EACH,IAAMA,UAAU,GADb,IAAA,sBAAA,GACH;;EAIA,sBAAsBC,KAAK,CAALA,QAAAA,CAAe;IAAA,OAAMC,QAAQ,CAACF,UAAU,CAL3D,QAKiDA,EAAD,CAAd;EAAA,CAAfC,CAAtB;EAAA;EAAA,IAAM,SAAN;;EAGA,IAAME,WAAW,GAAGF,KAAK,CAALA,MAAAA,CAApB,QAAoBA,CAApB;EAEAA,KAAK,CAALA,SAAAA,CAAgB,YAAM;IACpBE,WAAW,CAAXA,OAAAA,GAAAA,QAAAA;EADFF,CAAAA;EAIAA,KAAK,CAALA,SAAAA,CAAgB,YAAM;IACpB,IAAMG,WAAW,GAAG,UAAU,CAAV,WAAA,CAAA,OAAA,EAAiCC,UAAAA,CAAD,EAAO;MACzDC,SAAS,CAACH,WAAW,CAAXA,OAAAA,CAAoBE,CAAC,CAADA,IAAAA,CAA9BC,KAAUH,CAAD,CAATG;IADF,CAAoB,CAApB;IAIA,OAAA,WAAA;EALFL,CAAAA,EAMG,CANHA,UAMG,CANHA;EAQA,OAAOC,QAAQ,CAACF,UAAU,CAA1B,QAAgBA,EAAD,CAAf;AACD","sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationProp } from './types';\nimport useNavigation from './useNavigation';\n\ntype Selector<ParamList extends ParamListBase, T> = (\n  state: NavigationState<ParamList>\n) => T;\n\n/**\n * Hook to get a value from the current navigation state using a selector.\n *\n * @param selector Selector function to get a value from the state.\n */\nexport default function useNavigationState<ParamList extends ParamListBase, T>(\n  selector: Selector<ParamList, T>\n): T {\n  const navigation = useNavigation<NavigationProp<ParamList>>();\n\n  // We don't care about the state value, we run the selector again at the end\n  // The state is only to make sure that there's a re-render when we have a new value\n  const [, setResult] = React.useState(() => selector(navigation.getState()));\n\n  // We store the selector in a ref to avoid re-subscribing listeners every render\n  const selectorRef = React.useRef(selector);\n\n  React.useEffect(() => {\n    selectorRef.current = selector;\n  });\n\n  React.useEffect(() => {\n    const unsubscribe = navigation.addListener('state', (e) => {\n      setResult(selectorRef.current(e.data.state));\n    });\n\n    return unsubscribe;\n  }, [navigation]);\n\n  return selector(navigation.getState());\n}\n"]},"metadata":{},"sourceType":"script"}